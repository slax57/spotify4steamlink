/*
  Simple program to help with running librespot and handling audio.
  What it does :
  - Display a simple background image (containing usage instructions)
  - Start librespot program with a pipe to handle audio data
  - Feed the audio data to SDL audio component
  - Stop librespot program when exiting

  Many thanks to the librespot-org project: https://github.com/librespot-org/librespot
*/

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <stdbool.h>

#ifdef __EMSCRIPTEN__
#include <emscripten/emscripten.h>
#endif

#include "SDL.h"
#include "SDL_ttf.h"

#define INITIAL_WINDOW_WIDTH    1280
#define INITIAL_WINDOW_HEIGHT   720

#define AUDIO_SAMPLES           4096

#define LIBRESPOT_BIN_STEAML    "/home/apps/spotify4steamlink/librespot-org-build/arm-unknown-linux-gnueabihf/release/librespot"
#define LIBRESPOT_BIN_TEST      "/home/osboxes/workspace/spotify4steamlink/librespot-org-build/x86_64-unknown-linux-gnu/release/librespot"
#define LIBRESPOT_KILL_CMD      "killall librespot"

#define BACKGROUND_BMP_FILE     "romfs/data/spotify3.bmp"

#define FONT_FILE               "romfs/data/consolas.ttf"
#define FONT_SIZE               18

// Disable this flag when publishing to steamlink
#define TEST_MODE

#ifdef TEST_MODE
#define LIBRESPOT_BIN           LIBRESPOT_BIN_TEST
#else
#define LIBRESPOT_BIN           LIBRESPOT_BIN_STEAML
#endif // TEST_MODE


/* -- Global variables -- */

char *const paramList[] = {LIBRESPOT_BIN, "--disable-audio-cache", "--name", "steamlink", "--bitrate", "320", "--initial-volume", "85", "--backend", "pipe", NULL};
char *const testParamList[] = {LIBRESPOT_BIN, "-u", "slax57", "--disable-audio-cache", "--onevent", "./onevent.sh", "--name", "steamlink", "--bitrate", "320", "--initial-volume", "85", "--backend", "pipe", NULL};

static SDL_Texture *sprite;
static int sprite_w, sprite_h;
SDL_Renderer *renderer;
int done;
static FILE *audio_buf; // global pointer to the audio buffer to be played
int pipefd[2]; // Pipe file descriptor
pid_t cpid; // Subprocess PID
bool is_playing = false;
char* lastTrackId = NULL;
TTF_Font *font = NULL;
SDL_Color text_color = {255, 255, 255}; // white
SDL_Surface *text_surf = NULL;


/* -- Functions -- */

/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */
static void
quit(int rc)
{
    exit(rc);
}

void logout(char *text) {
    fputs(text, stdout);
    fputs("\n", stdout);
}

void logerr(char *text) {
    fputs(text, stderr);
    fputs("\n", stderr);
}

int
LoadSprite(char *file, SDL_Renderer *renderer)
{
    SDL_Surface *temp;

    /* Load the sprite image */
    temp = SDL_LoadBMP(file);
    if (temp == NULL) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't load %s: %s\n", file, SDL_GetError());
        return (-1);
    }
    sprite_w = temp->w;
    sprite_h = temp->h;

    /* Create textures from the image */
    sprite = SDL_CreateTextureFromSurface(renderer, temp);
    if (!sprite) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create texture: %s\n", SDL_GetError());
        SDL_FreeSurface(temp);
        return (-1);
    }
    SDL_FreeSurface(temp);

    /* We're ready to roll. :) */
    return (0);
}

// Render a sprite fullscreen
void
renderBackground(SDL_Renderer * renderer, SDL_Texture * sprite)
{
    /* Draw a dark background */
    SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0xFF);
    SDL_RenderClear(renderer);

    /* Blit the sprite onto the screen */
    SDL_RenderCopy(renderer, sprite, NULL, NULL);
}

// audio callback function
// Read fifo generated by spotify and add it to the audio queue
void my_audio_callback(void *userdata, Uint8 *dest_stream, int len) {

    ssize_t actual_samples_read = read(pipefd[0], dest_stream, sizeof(Uint8) * len);
    //int actual_samples_read = fread(dest_stream, sizeof(Uint8), len, audio_buf);
    if (actual_samples_read < len) {
        int i;
        for (i=0; i<len; i++) {
            dest_stream[i] = 0;
        }
        is_playing = false;
    } else {
        is_playing = true;
    }
}

void displayText(SDL_Renderer * renderer, char* buffer, int pos_x, int pos_y, int text_w) {
    // Create surface
    text_surf = TTF_RenderUTF8_Blended_Wrapped(font, buffer, text_color, text_w);
    if (text_surf == NULL) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create text surface from char buffer: %s\n", SDL_GetError());
        return;
    }
    // Create texture from the surface
    SDL_Texture *sprite = SDL_CreateTextureFromSurface(renderer, text_surf);
    if (!sprite) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create texture from text surface: %s\n", SDL_GetError());
        SDL_FreeSurface(text_surf);
        quit (-1);
    }
    // Set the position and size of source and destination rectangles
    SDL_Rect *srcrect = (SDL_Rect *)malloc(sizeof(SDL_Rect));
    srcrect->x = 0;
    srcrect->y = 0;
    srcrect->w = text_surf->w;
    srcrect->h = text_surf->h;
    SDL_Rect *dstrect = (SDL_Rect *)malloc(sizeof(SDL_Rect));
    dstrect->x = pos_x;
    dstrect->y = pos_y;
    dstrect->w = text_surf->w;
    dstrect->h = text_surf->h;
    // Blit the text onto the screen
    SDL_RenderCopy(renderer, sprite, srcrect, dstrect);// Free memory
    SDL_FreeSurface(text_surf);
    SDL_DestroyTexture(sprite);
    free(dstrect);
    free(srcrect);
}

void displayPlaybackStatus(SDL_Renderer * renderer) {
    // Computing text to be written
    char* buffer;
    if (is_playing) {
        buffer = "Playing";
    } else {
        buffer = "Paused";
    }
    // Call displayText
    displayText(renderer, buffer, 500, 300, 300);
}

void displayCurrentTrackId(SDL_Renderer * renderer) {
    // Computing text to be written

    // FIXME - Optimize file opening and closing
    // FIXME - define track id length (22) as constant
    char source[22];
    FILE *fp = fopen("track_id.txt", "r");
    if (fp != NULL) {
        size_t newLen = fread(source, sizeof(char), 22, fp);
        if ( ferror( fp ) != 0 ) {
            logerr("Error reading file");
        } else {
            source[newLen++] = '\0'; /* Just to be safe. */
        }

        fclose(fp);
    }

    if (source > 0) {
        // Call displayText
        displayText(renderer, source, 500, 400, 300);
    }
}

void loop()
{
    SDL_Event event;

    /* Check for events */
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
        case SDL_CONTROLLERDEVICEADDED:
            SDL_GameControllerOpen(event.cdevice.which);
            break;
        case SDL_CONTROLLERBUTTONDOWN:
        case SDL_KEYDOWN:
        case SDL_QUIT:
            done = 1;
            break;
        }
    }

    // render background image
    renderBackground(renderer, sprite);

    // display playback status
    displayPlaybackStatus(renderer);

    // display current track id
    displayCurrentTrackId(renderer);

    /* Update the screen! */
    SDL_RenderPresent(renderer);

#ifdef __EMSCRIPTEN__
    if (done) {
        emscripten_cancel_main_loop();
    }
#endif
}

// Init audio device and audio spec + start playing
void initAudio() {
    // Initialize SDL.
	if (SDL_Init(SDL_INIT_AUDIO) < 0)
			quit(1);

	static SDL_AudioSpec want; // the specs of our piece of music
	SDL_memset(&want, 0, sizeof(want));
	want.freq = 44100;
	want.format = AUDIO_S16;
	want.channels = 2;
	want.samples = AUDIO_SAMPLES;
	// set the callback function
	want.callback = my_audio_callback;
	//want.callback = NULL;
	want.userdata = NULL;
	/* Open the audio device */
	if ( SDL_OpenAudio(&want, NULL) < 0 ){
	  SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't open audio: %s\n", SDL_GetError());
	  quit(-1);
	}

	/* Start playing */
	SDL_PauseAudio(0);
}


// Stop the audio device properly
void stopAudio() {
    // shut everything down
	SDL_CloseAudio();
}


/* -- MAIN function -- */

int
main(int argc, char *argv[])
{
    // Close any pre-existing spotify instance: let's start clean!
    system(LIBRESPOT_KILL_CMD);

    // Init pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    logout("Pipe initialized");

    // Forking current process
    cpid = fork();
    if (cpid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    logout("Current process forked");

    // Child process code
    if (cpid == 0) {    /* Child reads from pipe */

        logout("child - In child process!");

        while ((dup2(pipefd[1], STDOUT_FILENO) == -1) && (errno == EINTR)) {} // Connect the entrance of the pipe to STDOUT_FILENO within the child process

        logerr("child - stdout redirected!");

        int password_fds = open("./password.txt", O_RDONLY);
        if(dup2(password_fds, STDIN_FILENO) < 0) {
            exit(EXIT_FAILURE);
        }

        logerr("child - stdin redirected!");

        close(pipefd[1]);          // Close unused write end
        close(pipefd[0]);          // Close unused read end

        logerr("child - pipe ends closed");

        // Make sure the env variable "http_proxy" is not set
        unsetenv("http_proxy");

        logerr("child - starting librespot");

        // Exec librespot command
#ifdef TEST_MODE
        execv(LIBRESPOT_BIN, testParamList);
#else
        execv(LIBRESPOT_BIN, paramList);
#endif // TEST_MODE

        logerr("child - AN ERROR OCCURED!");

        // If we get here it means the command failed
        perror("execv");
        _exit(1);
    }

    // Parent process code

    logout("parent - In parent process!");

    close(pipefd[1]);          // Close unused write end

    logout("parent - pipe write end closed");

    /* SDL Init - Graphics */
    SDL_Window *window;
    // Enable standard application logging
    SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);
    // Create window and renderer
#ifdef TEST_MODE
    Uint32 flags = SDL_WINDOW_SHOWN;
#else
    Uint32 flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
#endif // TEST_MODE
    if (SDL_CreateWindowAndRenderer(INITIAL_WINDOW_WIDTH, INITIAL_WINDOW_HEIGHT, flags, &window, &renderer) < 0) {
        quit(2);
    }
    // Load the background image
    if (LoadSprite(BACKGROUND_BMP_FILE, renderer) < 0) {
        quit(2);
    }
    // Init subsystem with game controller support
    SDL_InitSubSystem( SDL_INIT_GAMECONTROLLER );

    logout("parent - SDL initialized!");

    /* SDL Init - Audio */
    // Open audio device and start playback
    initAudio();

    logout("parent - Audio initialized!");

    /* SDL Init - TTF */
    if(TTF_Init() == -1)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Error in TTF_Init: %s\n", TTF_GetError());
        quit(EXIT_FAILURE);
    }

    logout("parent - TTF initialized!");

    // Load Font file
    font = TTF_OpenFont(FONT_FILE, FONT_SIZE);
    if(font < 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Error while creating font: %s\n", TTF_GetError());
        quit(EXIT_FAILURE);
    }

    logout("parent - font created");

    /* Main render loop */
    done = 0;
#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(loop, 0, 1);
#else
    while (!done) {
        loop();
    }
#endif

    logout("parent - main loop ended");

    // End child process
    kill(cpid, SIGKILL);

    logout("parent - child process (librespot) terminated");

    // Close pipe
    close(pipefd[0]);

    logout("parent - pipe read end closed");

    /* SDL Close - Audio */
    stopAudio();

    logout("parent - audio stopped");

    /*SDL Close - TTF */
    TTF_CloseFont(font);
    TTF_Quit();

    logout("parent - TTF stopped");

    /* SDL Close - Graphics */
    SDL_QuitSubSystem( SDL_INIT_GAMECONTROLLER );

    logout("parent - SDL exited");

    quit(0);

    return 0; /* to prevent compiler warning */
}


